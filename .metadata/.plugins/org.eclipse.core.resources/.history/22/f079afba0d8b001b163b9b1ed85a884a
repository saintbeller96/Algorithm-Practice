package P1953최단경로;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class TTT {
   // V: 정점의 개수, E: 간선의 개수, start: 시작 정점의 번호

   static class Node {
      ArrayList<int[]> adjList;

      public Node() {
         this.adjList = new ArrayList<>();
      }

   }

   public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      StringTokenizer st = new StringTokenizer(br.readLine().trim());

      int V, E, start;

      // 인접 리스트
      Node[] adjList;

      // 다익스트라의 비용을 담는 array
      int[] distance;

      // 다익스트라에서 사용할 PriorityQueue (가장 짧은 거리의 정점부터 나와야 해서)
      PriorityQueue<int[]> que;
      V = Integer.parseInt(st.nextToken());
      E = Integer.parseInt(st.nextToken());
      start = Integer.parseInt(br.readLine().trim());
      adjList = new Node[V + 1];
      distance = new int[V + 1];

      que = new PriorityQueue<>(new Comparator<int[]>() {

         // int[] o1 = {정점, 가중치}, 가중치 기준으로 작은 순으로
         @Override
         public int compare(int[] o1, int[] o2) {
            return o1[1] - o2[1];
         }

      });
      for (int i = 1; i <= V; i++) {
         adjList[i] = new Node();
      }

      for (int i = 0; i < E; i++) {
         st = new StringTokenizer(br.readLine().trim());
         int u = Integer.parseInt(st.nextToken()); // 시작 정점
         int v = Integer.parseInt(st.nextToken()); // 도착 정점
         int w = Integer.parseInt(st.nextToken()); // 가중치
//         boolean found = false;
         ArrayList<int[]> curList = adjList[u].adjList;
//         for (int[] curNode : curList) {
//            // u에 연결된 v가 이미 있는데 이미 있던 가중치가 새로 받은 값보다 크면, 갱신시켜준다
//            if (curNode[0] == v) {
//               if (curNode[1] > w)
//               {
//                  curNode[1] = w;
//               }
//               found = true;
//               break;
//            }
//         }
//         if (!found)
         curList.add(new int[] { v, w });

      }
      Arrays.fill(distance, Integer.MAX_VALUE);
      distance[start] = 0;

      // Dijkstra
      // distance: start(입력받은 시작노드) 부터 i번째 node까지의 최단거리를 저장한 node
      que.add(new int[] { start, 0 });
      while (!que.isEmpty()) {
         // pq에서 가장 거리가 짧은 아이 선택해줌
         int[] cur = que.poll();
         if (distance[cur[0]] < cur[1])
            continue;
         for (int[] next : adjList[cur[0]].adjList) {
            // next[0] <= 정점
            // next[1] <= cur정점부터 next정점까지의 거리
            // (start~cur까지의 거리 + cur=>next)까지의 거리와 (start~next)까지의 거리를 비교
            if (distance[cur[0]] + next[1] < distance[next[0]]) {
               // 업데이트
               distance[next[0]] = distance[cur[0]] + next[1];
               que.add(new int[] {next[0], next[1] + cur[1]});
            }
         }
      }
      for (int i = 1; i <= V; i++) {
         if (distance[i] == Integer.MAX_VALUE) {
            System.out.println("INF");// 만약 거리가 여전히 Max값이면 INF출력
         } else {
            System.out.println(distance[i]);
         }
      }

      br.close();
   }

}